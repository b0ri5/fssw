# Introduction #

Our goal is to implement the Schreier Sims algorithm and make a usable C++ library around it. This documents our understanding of the algorithm. The references used are _Permutation Group Algorithms_ (Seress, 2003) and _The Handbook of Computational Group Theory_ (Holt, 2005).

# Preliminaries #

We're dealing with permutation groups so here are the basics:
  * _O<sub>n</sub>_ = { 1, 2, ..., _n_ }
  * Elements of _O<sub>n</sub>_ are denoted by _a_ and _b_ usually
  * Elements of _G_ are denoted by _g_ usually
  * Sym(_O<sub>n</sub>_) is the group (under composition) of all permutations of _O<sub>n</sub>_
  * _G_ <= Sym(_O<sub>n</sub>_)
  * _e_ \in _G_ is the identity
  * Group actions are denoted via exponentiation: _a^g_
  * Orbit(_G_, _a_) = { _a<sup>g</sup>_ : _g_ \in _G_ } is the orbit of _a_ in _G_
  * < _S_ > = _G_ means the subset _S_ of _G_ generates _G_ (or, G is the closure of S)
  * _G<sub>X</sub>_ = { _g_ \in _G_ : _X<sup>g</sup>_ = _X_ } is the stabilizer of _X_ (any object _G_ acts on) in _G_

**Definition** (base of a permutation group). A _base_ of a permutation group _G_ is a sequence of elements _B = (b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>k</sub>)_ such that _G<sub>B</sub>_ = { _e_ }. In other words, any permutation which fixes the elements of _B_ also fixes every other element in _O<sub>n</sub>_.

**Definition** (subgroup chain). A _subgroup chain_ of a permutation group _G_ with respect to a base _B_ for _G_ is
> _G = G<sup>(1)</sup> >= G<sup>(2)</sup> >= ... >= G<sup>(k+1)</sup> = e_
where _G<sup>(i)</sup> = G<sub>(b_1, b_2, ..., b_i)</sub>_ for 1 <= _i_ <= k+1. That is, _G<sup>(i)</sup>_ fixes the first _i-1_ elements of _B_.

**Definition** (strong generating set). A _strong generating set_ (SGS) of a group _G_ with respect to a base _B_ is a subset of _G_ with the property that
> < _S_ \cap _G<sup>(i)</sup>_ > = _G<sup>(i)</sup>_ for 1 <= _i_ <= k+1. The intersection _S_ \cap _G<sup>(i)</sup>_ is denoted _S<sub>i</sub>_.

**Definition** (fundamental orbits). The _fundamental orbits_ of a group _G_ with respect to a base _B = (b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>k</sub>)_ are
> Orbit(_G<sup>(i)</sup>_, _b<sub>i</sub>_) for 1 <= _i_ <= _k_.

**Definition** (Schreier tree data structure). A _Schreier tree data structure_ for a strong generating set _S_ of a group _G_ with respect to the base _B_ is a sequence of trees _T<sub>i</sub>_ for 1 <= i <= k (one for each base point). The tree _T<sub>i</sub>_ is a rooted directed labeled tree rooted at and directed to _b<sub>i</sub>_. Its vertex set is Orbit(_G<sup>(i)</sup>_, _b<sub>i</sub>_) and the edge a-->b is labeled by a permutation _g_ such that _a<sup>g</sup>_ = _b_. So, the composition of the edge-labels on the path from a vertex _a_ to the root _b<sub>i</sub>_ maps _a_ to _b<sub>i</sub>_. The sequence _T<sub>i</sub>_ for 1 <= _i_ <= _k_ will be abbreviated by _**T**_

# The _strip_ algorithm #

Given a Schreier tree data structure _**T**_ for a strong generating set _S_ with a base _B_, the strip algorithm attempts to reduce a permutation _g_ in Sym(_O<sub>n</sub>_) to the identity. If successful, the permutation _g_ is in the group _G_ generated by _S_. In other words, it can be used for membership testing (it is also useful for constructing a strong generating set in the first place).

It works as follows,
  * Let h = g
  * For each 1 <= _i_ <= _k_
    * Let _a_ = _b<sub>i</sub><sup>h</sup>_
    * If _a_ is not a vertex in the tree _T<sub>i</sub>_, return _h_
    * Otherwise, let _u_ be the composition of the edge-labels on the path from _a_ to _b<sub>i</sub>_ in _T<sub>i</sub>_
    * Set _h_ = _h_ `*` _u_
  * Return _h_

In other words:

```
def strip(g, T[1..k]):
  Input: permutation g, and Schreier tree data structure T[i] for 1 <= i <= k
  Output: permutation h, the result of trying to undress g as much as possible
  
  h = g

  for i in [1..k]:
    a = b[i]^h
    if not a in T[i]:
      return h, i
    else
      let u be the composition of edge-labels on the path from a to b[i] in T[i]
      h = h * u

  return h, k + 1
```


# The Schreier Sims Algorithm #

Given a Base $B$ of a group $G$ generated by $S$, the Schreier Sims algorithm
TODO: elaborate on this explanation to make the algorithm make sense.

```
def schreier_sims(B, S):
  # ensure that B is a base
  for s in S:
    if x in G_{b1, ..., bk}:
      let a be an element moved by s
      append(B, a)
      k = k + 1

  # set up the schreier trees
  for i in [1..k]:
    S^(i) = S intersect G_{b1, ..., b_{i-1}}
    H^(i) = <S^(i)>
    Orbit^(i) = b_i^{H(i)}
  
  # now H^(k+1) = e

  i = k

  while i >= 1:
    # test condition that H^(i)_{b_i} = H^(i+1)
    for a in Orbit^(i):
      find g_a in H^(i) such that b_i^{g_a} = a
      for s in S^(i):
        find g_as in H^(i) such that b_i^{g_as} = a^s
        if g * s != g_as:
          # test if Schreier gen. g_a * s * g_as^{-1} in H^(i+1)
          y = true
          h, j = strip(g_a * s * g_as^{-1}, B, S, Orbits)
          if j <= k:
            # new strong gen. h at level j
            y = false
          elif !h.is_identity():
            # h fixes all base points... so B isn't a base
            y = false
            let a such that a^h != a
            append(B, a)
            k = k + 1
            S^(k) = []

          if y == false:
            for l in [i+1..j]:
              append(S^(l), h)
              H^(l) = <S^(l)>
              Orbit^(l) = b_l^{H^(l)}
              i = j
              continue i

          # g_a * s * g_as^{-1} in H^(i+1) has been verified

    # condition H_b^i^(i) = H^(i+1) is verified
    i = i - 1

S = Union_{i=1}^k S^(i)
```